<?php

declare(strict_types=1);

namespace PWP\includes\API\endpoints;

use League\OAuth2\Client\Provider\GenericProvider;
use PWP\includes\authentication\PWP_Authenticator;
use WP_REST_Response;

class PWP_TEST_OAuth2_Client_Endpoint extends PWP_Abstract_READ_Endpoint
{
    public function __construct()
    {
        parent::__construct(
            'test',
            'test',
            '',
            new PWP_Authenticator()
        );
    }

    public function do_action(\WP_REST_Request $request): WP_REST_Response
    {
        $provider = new \League\OAuth2\Client\Provider\GenericProvider([
            'clientId'                  => 'zBYTuDb4yLOp9Pz3VVgDO3BYy4Av4PbmJjCpsHxe',    // The client ID assigned to you by the provider
            'clientSecret'              => '6pTQg39qKD5wlzfMobYcgV65Z5i8k8DCO0O4Fout',    // The client password assigned to you by the provider
            'redirectUri'               => 'https://localhost/testsite/wp-json/test/test',
            'urlAuthorize'              => 'https://devwebshop.peleman.com/oauth/authorize',
            'urlAccessToken'            => 'https://devwebshop.peleman.com/oauth/token',
            'urlResourceOwnerDetails'   => 'https://devwebshop.peleman.com/oauth/me',
            'urlPublicKeys'             => 'https://devwebshop.peleman.com/.well-known/keys/',
            'scope'                     => 'openid'
        ]);

        // If we don't have an authorization code then get one
        if (!isset($_GET['code'])) {

            $this->make_auth_grant_request($provider);
            // Check given state against previously stored one to mitigate CSRF attack
        }
        if (
            empty($_GET['state']) ||
            (isset($_SESSION['oauth2state']) && $_GET['state'] !== $_SESSION['oauth2state'])
        ) {
            unset($_SESSION['oauth2state']);
            exit('Invalid state');
        }

        $this->make_auth_token_request($provider);
        return new WP_REST_Response();
    }

    private function make_auth_grant_request(GenericProvider $provider): void
    {
        $options = array(
            'scope' => ['openid'],
        );
        $authorizationUrl = $provider->getAuthorizationUrl($options);
        $_SESSION['oauth2state'] = $provider->getState();
        //redirect to authorization url. Full url with parameters is generated by provider
        header('Location: ' . $authorizationUrl);
        exit;
    }

    private function make_auth_token_request(GenericProvider $provider): void
    {
        try {

            // Try to get an access token using the authorization code grant.
            $accessToken = $provider->getAccessToken('authorization_code', [
                'code' => $_GET['code'],
            ]);

            // We have an access token, which we may use in authenticated
            // requests against the service provider's API.
            echo 'Access Token: ' . $accessToken->getToken() . "<br>";
            echo 'Refresh Token: ' . $accessToken->getRefreshToken() . "<br>";
            echo 'Expired in: ' . $accessToken->getExpires() . "<br>";
            echo 'Already expired? ' . ($accessToken->hasExpired() ? 'expired' : 'not expired') . "<br>";
            echo 'ID token: ' . print_r($accessToken->getValues()['id_token'], true) . "<br>";

            // Using the access token, we may look up details about the
            // resource owner.
            $resourceOwner = $provider->getResourceOwner($accessToken);

            var_export($resourceOwner->toArray());

            // The provider provides a way to get an authenticated API request for
            // the service, using the access token; it returns an object conforming
            // to Psr\Http\Message\RequestInterface.
            $request = $provider->getAuthenticatedRequest(
                'GET',
                'https://service.example.com/resource',
                $accessToken
            );
        } catch (\League\OAuth2\Client\Provider\Exception\IdentityProviderException $e) {

            // Failed to get the access token or user details.
            exit($e->getMessage());
        }
    }

    public function get_schema(): array
    {
        return [];
    }
}
